# Benefits of Store
Throughout the [overview](overview.md) we touched briefly on the advantages of utilizing Store over a typical, Angular 1 style approach but let's take a moment to recap. Why take the time to invest in this particular library, architecture pattern, and learning curve? The primary advantage to a Store-based application are __centralized state__, __performance__, __testability__, and __tooling__.
##### Centralized, Immutable State
All relevant application state exists in one location. This makes it easier to track down problems, as a snapshot of state at the time of an error can provide important insight and make it easy to recreate issues. This also makes notoriously hard problems such as undo/redo trivial in the context of a Store application and enables powerful tooling.
##### Performance
Since state is centralized at the top of your application, data updates can flow down through your components relying on slices of store. Angular 2 is built to optimize on such a data-flow arrangement, and can disable change detection in cases where components rely on Observables which have not emitted new values. In an optimal store solution this will be the vast majority of your components.
##### Testability
All state updates are handled in reducers, which are pure functions. Pure functions are extremely simple to test, as it is simply input in, assert against output. This enables the testing of the most crucial aspects of your application without mocks, spies, or other tricks that can make testing both complex and error prone. 
##### Tooling and Ecosystem
A centralized, immutable state also enables powerful tooling. One such example is [ngrx developer tools](https://github.com/ngrx/devtools), which provides a history of actions and state changes, allowing for <sup>1</sup> *time travel* during development. 
The patterns provided by Store also allow for a rich ecosystem of easy to implement utilities. Because all actions flow through a common reducer, problems such as syncing slices of state to [local storage](https://github.com/btroncone/ngrx-store-localstorage), [advanced logging](https://github.com/btroncone/ngrx-store-logger), and [undo/redo](http://plnkr.co/edit/Hb4pJP3jGtOp6b7JubzS?p=preview) are easily solved with a few lines of code. This ecosystem will only grow over time. 

<sup>1 Manipulating the history of dispatched actions and state changes to emulate a point in time of application interaction.</sup>